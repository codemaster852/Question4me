<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Question4me - Multiplayer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Animation & Base Styles --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: #0f172a; /* bg-slate-900 */
            background-image: 
                radial-gradient(circle at 25% 25%, hsla(215, 98%, 52%, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, hsla(339, 80%, 50%, 0.1) 0%, transparent 50%);
            background-size: 100% 100%;
        }
        .font-cairo { font-family: 'Cairo', sans-serif; }

        /* --- Main Button Styling --- */
        .btn {
            @apply w-full text-white font-bold py-3 px-4 rounded-xl text-lg transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed border-b-4 shadow-lg;
            transform-style: preserve-3d;
        }
        .btn:not(:disabled):hover {
            @apply brightness-110;
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .btn:not(:disabled):active {
            transform: translateY(1px);
            @apply border-b-2;
        }
        .btn-primary { @apply bg-cyan-500 border-cyan-700; }
        .btn-primary:not(:disabled):active { @apply bg-cyan-600; }

        .btn-secondary { @apply bg-amber-500 border-amber-700; }
        .btn-secondary:not(:disabled):active { @apply bg-amber-600; }

        .btn-danger { @apply bg-red-600 border-red-800; }
        .btn-danger:not(:disabled):active { @apply bg-red-700; }
        
        .btn-gray { @apply bg-slate-600 border-slate-800 text-slate-200; }
        .btn-gray.active { @apply bg-cyan-500 border-cyan-700 text-white ring-2 ring-cyan-300; }

        /* --- Choice Button Styling --- */
        .btn-choice {
            @apply w-full p-4 rounded-xl text-lg text-left transition-all duration-200 border-2 border-slate-600 bg-slate-700;
        }
        .btn-choice:hover:not(:disabled) {
            @apply bg-slate-600 border-cyan-400;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 200, 255, 0.1);
        }
        .correct {
            background-image: linear-gradient(to right, #28a745, #22c55e) !important;
            color: white !important;
            border-color: #166534 !important;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
        .incorrect {
            background-image: linear-gradient(to right, #dc3545, #ef4444) !important;
            color: white !important;
            border-color: #991b1b !important;
            opacity: 0.8;
        }

        /* --- Loader & Screen Transitions --- */
        .loader {
            border: 6px solid #475569; /* slate-600 */
            border-radius: 50%;
            border-top: 6px solid #06b6d4; /* cyan-500 */
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .screen {
            display: none;
            animation: fadeIn 0.5s ease-out;
        }
        .screen.active { display: block; }
        
        /* --- UI Element Styling (Glassmorphism) --- */
        #app-container {
            @apply bg-slate-800/50 backdrop-blur-xl border border-slate-700/50 rounded-3xl p-6 md:p-8 shadow-2xl shadow-black/50;
        }
        #game-area {
            @apply bg-slate-900/60 border border-slate-700;
        }
        #lobby-code {
            @apply bg-slate-900 border-2 border-dashed border-slate-600 text-amber-400;
        }
        input[type="text"], input[type="number"] {
            @apply w-full p-4 bg-slate-900/70 border-2 border-slate-600 rounded-xl text-lg text-center;
            @apply focus:outline-none focus:ring-2 focus:ring-cyan-400 focus:border-transparent transition-all;
        }
        #game-timer {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-4">

    <div id="app-container" class="w-full max-w-2xl mx-auto">

        <!-- Home Screen -->
        <div id="home-screen" class="screen active text-center">
            <h1 class="text-5xl font-bold text-cyan-400 mb-2">Question4me</h1>
            <p class="text-xl text-slate-400 mb-8 font-cairo">اسألني</p>
            <div class="space-y-4">
                <button id="single-player-btn" class="btn btn-primary">Single Player</button>
                <button id="friends-mode-btn" class="btn btn-secondary">Friends Mode</button>
            </div>
        </div>

        <!-- Friends Mode Screen -->
        <div id="friends-mode-screen" class="screen text-center">
            <h2 class="text-4xl font-bold text-amber-400 mb-8">Friends Mode</h2>
            <div class="space-y-4">
                <button id="create-room-btn" class="btn btn-primary">Create Room</button>
                <div class="bg-slate-800 p-4 rounded-lg">
                    <input type="text" id="room-code-input" placeholder="Enter Room Code">
                    <button id="join-room-btn" class="btn btn-secondary mt-3">Join Room</button>
                </div>
                 <button id="back-to-home-btn-1" class="btn btn-danger mt-4">Back</button>
            </div>
        </div>
        
        <!-- Game Settings Screen -->
        <div id="game-settings-screen" class="screen text-center">
            <h2 class="text-4xl font-bold text-cyan-400 mb-8">Game Settings</h2>
            <p class="text-slate-300 mb-6 -mt-4">Each question has a 10 second time limit!</p>
            <div class="space-y-6">
                <div>
                    <h3 class="text-2xl mb-3">Game Mode</h3>
                    <div class="grid grid-cols-2 gap-4">
                        <button class="game-mode-btn btn btn-gray" data-mode="survival">Survival</button>
                        <button class="game-mode-btn btn btn-gray" data-mode="questions">Questions</button>
                    </div>
                </div>
                 <div id="questions-settings" class="hidden">
                    <h3 class="text-2xl mb-3">Number of Questions</h3>
                    <input type="number" id="questions-number-input" class="tracking-normal" value="10" min="1" max="50">
                </div>
            </div>
             <button id="start-game-btn" class="btn btn-primary mt-8" disabled>Select a Mode to Start</button>
             <button id="back-to-home-btn-2" class="btn btn-danger mt-4">Back</button>
        </div>

        <!-- Lobby Screen -->
        <div id="lobby-screen" class="screen text-center">
            <h2 class="text-3xl font-bold text-amber-400 mb-4">Lobby</h2>
            <p class="text-slate-400 mb-6">Share this code with your friend:</p>
            <div id="lobby-code" class="text-5xl font-bold p-4 rounded-lg cursor-pointer mb-6" title="Click to copy"></div>
            <p class="text-xl mb-4">Players in lobby:</p>
            <ul id="player-list" class="text-lg space-y-2 mb-8"></ul>
            <div id="host-controls" class="hidden my-6">
                <button id="start-game-from-lobby-btn" class="btn btn-primary" disabled>Start Game (Need 2 players)</button>
            </div>
            <div id="waiting-message">
                <div class="loader mx-auto"></div>
                <p class="mt-4">Waiting for another player to join...</p>
            </div>
            <p id="waiting-for-host-msg" class="hidden mt-4 text-lg">Waiting for the host to start the game...</p>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <header class="flex justify-between items-center mb-4">
                <div id="player1-info" class="text-left w-1/3">
                    <div id="player1-name" class="text-lg font-bold text-cyan-400 truncate">Player 1</div>
                    <div id="player1-score" class="text-xl font-bold">Score: 0</div>
                </div>
                <div id="game-timer" class="text-5xl font-bold text-amber-400 text-center w-1/3">10</div>
                <div id="player2-info" class="text-right w-1/3">
                    <div id="player2-name" class="text-lg font-bold text-red-400 truncate">Player 2</div>
                    <div id="player2-score" class="text-xl font-bold">Score: 0</div>
                </div>
            </header>
            <main id="game-area" class="p-6 md:p-8 rounded-2xl shadow-2xl min-h-[350px] flex flex-col justify-center items-center">
                <div id="loader-game" class="hidden loader"></div>
                <div id="game-content" class="w-full">
                    <div id="question-container" class="text-center">
                        <p id="question-text" class="text-2xl md:text-3xl font-semibold mb-6 leading-relaxed"></p>
                    </div>
                    <div id="type-answer-section">
                        <input type="text" id="answer-input" placeholder="Type your answer...">
                        <button id="submit-answer-btn" class="btn btn-primary mt-4">Submit Answer</button>
                    </div>
                    <div id="feedback-message" class="text-center text-2xl font-bold mt-6"></div>
                    <button id="next-question-btn" class="hidden btn btn-secondary mt-6">Next Question</button>
                </div>
            </main>
        </div>
        
        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen text-center">
            <h2 class="text-5xl font-bold text-cyan-400 mb-6">Game Over!</h2>
            <div id="game-over-message" class="text-3xl text-amber-400 mb-4"></div>
            <div id="final-scores" class="text-2xl space-y-2 mb-8"></div>
            <button id="play-again-btn" class="btn btn-primary">Play Again</button>
        </div>

    </div>

    <script type="module">
        // --- Firebase SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- DOM Elements ---
        const screens = document.querySelectorAll('.screen');
        const lobbyCodeEl = document.getElementById('lobby-code');
        const playerListEl = document.getElementById('player-list');
        const questionTextEl = document.getElementById('question-text');
        const answerInput = document.getElementById('answer-input');
        const submitAnswerBtn = document.getElementById('submit-answer-btn');
        const feedbackMessage = document.getElementById('feedback-message');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const loaderGame = document.getElementById('loader-game');
        const gameContent = document.getElementById('game-content');
        const timerEl = document.getElementById('game-timer');
        
        // --- Firebase & Game State ---
        let db, auth, userId, app;
        let currentRoomId = null;
        let roomUnsubscribe = null;
        let gameMode = null; // 'single' or 'friends'
        let gameSettings = { mode: null, value: null }; // mode: survival, questions. value: number of questions
        let singlePlayerState = {};
        let timerInterval = null;
        let questionTimeout = null;
        let correctAnswer = '';

        // --- Gemini API ---
        const geminiApiKey = "AIzaSyD4TajBc10KGNuKJ6HBGBvkJAG4A6bam6A";
        const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${geminiApiKey}`;

        // --- Functions ---
        
        function showScreen(screenId) {
            screens.forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        async function initializeFirebase() {
            // Use the globally provided Firebase config by the platform
            const firebaseConfig = typeof __firebase_config !== 'undefined' 
                ? JSON.parse(__firebase_config) 
                : null;

            if (!firebaseConfig || !firebaseConfig.apiKey) {
                console.error("Firebase configuration is missing or invalid.");
                // This alert is a fallback. The new init logic should prevent this.
                alert("CRITICAL ERROR: Firebase configuration is not available. The application cannot start.");
                return false; // Indicate failure
            }

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Use the globally provided auth token by the platform
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    userId = auth.currentUser.uid;
                    console.log("Firebase initialized and user signed in with custom token:", userId);
                } else {
                    // Fallback for local testing if the global token isn't available
                    await signInAnonymously(auth);
                    userId = auth.currentUser.uid;
                    console.log("Firebase initialized and user signed in anonymously (fallback):", userId);
                }
                return true; // Indicate success

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                if (error.code && (error.code.includes('identity-toolkit') || error.code.includes('auth/operation-not-allowed'))) {
                    alert("AUTHENTICATION FAILED:\n\nIf you are running this locally, please ensure 'Anonymous' sign-in is enabled in your Firebase project's Authentication settings and that the Identity Toolkit API is active in your Google Cloud project.");
                } else {
                    alert("Could not connect to the game servers. Please check the console for details.");
                }
                return false; // Indicate failure
            }
        }

        async function callGemini(prompt) {
            if (!geminiApiKey) {
                 alert("Gemini API key is missing. Please add it to the script.");
                 return null;
            }
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            try {
                const response = await fetch(geminiApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    console.error("Gemini API Error:", response.statusText);
                    return null;
                }
                const result = await response.json();
                return result.candidates?.[0]?.content?.parts?.[0]?.text || null;
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                return null;
            }
        }

        function setupListeners() {
            // Home
            document.getElementById('single-player-btn').onclick = () => {
                gameMode = 'single';
                showScreen('game-settings-screen');
            };
            document.getElementById('friends-mode-btn').onclick = () => {
                gameMode = 'friends';
                showScreen('friends-mode-screen');
            };
            document.getElementById('back-to-home-btn-1').onclick = () => showScreen('home-screen');
            document.getElementById('back-to-home-btn-2').onclick = () => resetToHome();

            // Friends
            document.getElementById('create-room-btn').onclick = createRoom;
            document.getElementById('join-room-btn').onclick = joinRoom;
            lobbyCodeEl.onclick = () => {
                // Use a fallback for clipboard API for security reasons in iframes
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = lobbyCodeEl.innerText;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('Room code copied to clipboard!');
                } catch (err) {
                    alert('Could not copy code.');
                }
            };

            // Game Settings
            setupGameSettingsListeners();
            
            // In-Game
            submitAnswerBtn.onclick = handleAnswerSubmission;
            answerInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') handleAnswerSubmission();
            });
            nextQuestionBtn.onclick = getNextQuestion;
            document.getElementById('play-again-btn').onclick = resetToHome;
            document.getElementById('start-game-from-lobby-btn').onclick = () => showScreen('game-settings-screen');
        }
        
        function setupGameSettingsListeners() {
            const modeButtons = document.querySelectorAll('.game-mode-btn');
            const startGameBtn = document.getElementById('start-game-btn');
            
            modeButtons.forEach(btn => {
                btn.onclick = () => {
                    modeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameSettings.mode = btn.dataset.mode;
                    
                    document.getElementById('questions-settings').classList.toggle('hidden', gameSettings.mode !== 'questions');
                    
                    if (gameSettings.mode === 'survival') {
                        gameSettings.value = 3; // 3 lives
                        startGameBtn.disabled = false;
                        startGameBtn.textContent = 'Start Survival Mode';
                    } else if (gameSettings.mode === 'questions') {
                        const qInput = document.getElementById('questions-number-input');
                        gameSettings.value = parseInt(qInput.value);
                        const isValid = gameSettings.value > 0;
                        startGameBtn.disabled = !isValid;
                        startGameBtn.textContent = isValid ? 'Start Game' : 'Enter a Valid Number';
                    }
                };
            });

            document.getElementById('questions-number-input').oninput = (e) => {
                 if(gameSettings.mode === 'questions') {
                    gameSettings.value = parseInt(e.target.value);
                    const isValid = gameSettings.value && gameSettings.value > 0;
                    startGameBtn.disabled = !isValid;
                    startGameBtn.textContent = isValid ? 'Start Game' : 'Enter a Number';
                 }
            };

            startGameBtn.onclick = () => {
                if(gameMode === 'single') {
                    startSinglePlayerGame();
                } else if (gameMode === 'friends' && currentRoomId) {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const roomRef = doc(db, "artifacts", appId, "public/data/rooms", currentRoomId);
                    updateDoc(roomRef, { 
                        gameSettings,
                        gameState: 'starting' 
                    });
                }
            };
        }

        // --- Multiplayer Logic ---

        async function createRoom() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
            currentRoomId = roomId;
            const roomRef = doc(db, "artifacts", appId, "public/data/rooms", currentRoomId);
            
            const player1 = { id: userId, name: `Player ${Math.floor(Math.random() * 1000)}`, score: 0, isHost: true };

            await setDoc(roomRef, {
                roomId: roomId,
                players: { [userId]: player1 },
                gameState: 'waiting',
                gameSettings: null, 
                createdAt: new Date(),
            });

            listenToRoomUpdates(roomId);
            showScreen('lobby-screen');
        }

        async function joinRoom() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const roomId = document.getElementById('room-code-input').value.toUpperCase();
            if (!roomId) return;
            
            const roomRef = doc(db, "artifacts", appId, "public/data/rooms", roomId);
            const roomSnap = await getDoc(roomRef);

            if (roomSnap.exists()) {
                const roomData = roomSnap.data();
                if (Object.keys(roomData.players).length < 2) {
                    currentRoomId = roomId;
                    const player2 = { id: userId, name: `Player ${Math.floor(Math.random() * 1000)}`, score: 0, isHost: false };
                    
                    await updateDoc(roomRef, { [`players.${userId}`]: player2 });
                    listenToRoomUpdates(roomId);
                    showScreen('lobby-screen');
                } else {
                    alert('Room is full!');
                }
            } else {
                alert('Room not found!');
            }
        }
        
        function listenToRoomUpdates(roomId) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            if (roomUnsubscribe) roomUnsubscribe();
            const roomRef = doc(db, "artifacts", appId, "public/data/rooms", roomId);
            roomUnsubscribe = onSnapshot(roomRef, (doc) => {
                if (!doc.exists()) {
                    alert("The host has left the game.");
                    resetToHome();
                    return;
                }

                const roomData = doc.data();
                const amIHost = roomData.players[userId]?.isHost;

                switch(roomData.gameState) {
                    case 'waiting':
                        updateLobbyUI(Object.values(roomData.players), amIHost);
                        break;
                    case 'starting':
                        showScreen('game-screen');
                        if (amIHost) {
                            generateAndSetNewQuestion(roomData);
                        }
                        break;
                    case 'active':
                        updateGameUI(roomData);
                        break;
                    case 'finished':
                        showGameOver(roomData);
                        break;
                }
            });
        }

        function updateLobbyUI(players, isHost) {
            lobbyCodeEl.textContent = currentRoomId;
            playerListEl.innerHTML = '';
            players.forEach(p => {
                const li = document.createElement('li');
                li.textContent = `${p.name} ${p.id === userId ? '(You)' : ''} ${p.isHost ? '👑' : ''}`;
                playerListEl.appendChild(li);
            });

            const hostControls = document.getElementById('host-controls');
            const waitingMsg = document.getElementById('waiting-message');
            const waitingForHostMsg = document.getElementById('waiting-for-host-msg');
            const lobbyStartBtn = document.getElementById('start-game-from-lobby-btn');
            
            if (isHost) {
                hostControls.classList.remove('hidden');
                waitingMsg.classList.add('hidden');
                waitingForHostMsg.classList.add('hidden');
                lobbyStartBtn.disabled = players.length < 2;
                lobbyStartBtn.textContent = players.length < 2 ? 'Start Game (Need 2 players)' : 'Proceed to Settings';
            } else {
                hostControls.classList.add('hidden');
                waitingMsg.classList.add('hidden');
                waitingForHostMsg.classList.remove('hidden');
            }
        }
        
        async function generateAndSetNewQuestion(roomData) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            clearTimers();
            loaderGame.classList.remove('hidden');
            gameContent.style.display = 'none';

            const prompt = `Generate a single, challenging trivia question about general knowledge. Return ONLY a valid JSON object with "question" (string) and "answer" (string) keys.`;
            const responseText = await callGemini(prompt);
            
            if (!responseText) {
                 questionTextEl.textContent = "Error loading question. Host may need to try again.";
                 return;
            }
            
            try {
                const cleanedText = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                const questionData = JSON.parse(cleanedText);

                const roomRef = doc(db, "artifacts", appId, "public/data/rooms", currentRoomId);
                const questionNumber = (roomData.questionNumber || 0) + 1;

                await updateDoc(roomRef, {
                    gameState: 'active',
                    currentQuestion: questionData,
                    questionNumber: questionNumber,
                    answers: {}, 
                    roundEndTime: Date.now() + 10000 // 10 second timer
                });

            } catch(e) {
                console.error("Failed to parse Gemini response:", e);
                generateAndSetNewQuestion(roomData); // Retry
            }
        }
        
        function updateGameUI(roomData) {
            clearTimers();
            loaderGame.classList.add('hidden');
            gameContent.style.display = 'block';

            feedbackMessage.textContent = '';
            answerInput.value = '';
            answerInput.disabled = false;
            submitAnswerBtn.disabled = false;
            
            const players = Object.values(roomData.players);
            const p1 = players.find(p => p.isHost) || {};
            const p2 = players.find(p => !p.isHost) || { name: 'Waiting...', score: 0 };
            
            document.getElementById('player1-info').style.visibility = 'visible';
            document.getElementById('player2-info').style.visibility = 'visible';
            document.getElementById('player1-info').style.margin = '';

            document.getElementById('player1-name').textContent = `${p1.name} ${p1.id === userId ? '(You)' : ''}`;
            document.getElementById('player1-score').textContent = `Score: ${p1.score}`;
            document.getElementById('player2-name').textContent = `${p2.name} ${p2.id === userId ? '(You)' : ''}`;
            document.getElementById('player2-score').textContent = `Score: ${p2.score}`;
            
            questionTextEl.textContent = roomData.currentQuestion.question;

            if (roomData.answers && roomData.answers[userId]) {
                answerInput.disabled = true;
                submitAnswerBtn.disabled = true;
                feedbackMessage.textContent = 'Waiting for other player...';
            }

            timerInterval = setInterval(() => {
                const timeLeft = Math.round((roomData.roundEndTime - Date.now()) / 1000);
                timerEl.textContent = timeLeft > 0 ? timeLeft : '0';
                if (timeLeft <= 0) {
                    clearTimers();
                    answerInput.disabled = true;
                    submitAnswerBtn.disabled = true;
                    if (roomData.players[userId]?.isHost) {
                        scoreMultiplayerRound(roomData);
                    }
                }
            }, 500);
            
            if (roomData.players[userId]?.isHost) {
                const totalPlayers = players.length;
                const submittedAnswers = roomData.answers ? Object.keys(roomData.answers).length : 0;
                if (totalPlayers > 1 && submittedAnswers === totalPlayers) {
                    clearTimers();
                    scoreMultiplayerRound(roomData);
                }
            }
        }

        async function scoreMultiplayerRound(roomData) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            if (roomData.gameState !== 'active') return;
            
            const roomRef = doc(db, "artifacts", appId, "public/data/rooms", currentRoomId);
            await updateDoc(roomRef, { gameState: 'scoring' });

            const batch = writeBatch(db);
            const currentPlayers = roomData.players;
            const answers = roomData.answers || {};
            const correctAnswerText = roomData.currentQuestion.answer.toLowerCase().trim();

            Object.keys(currentPlayers).forEach(playerId => {
                const playerAnswer = answers[playerId] ? answers[playerId].toLowerCase().trim() : '';
                if (playerAnswer === correctAnswerText) {
                    const newScore = (currentPlayers[playerId].score || 0) + 10;
                    batch.update(roomRef, { [`players.${playerId}.score`]: newScore });
                }
            });

            await batch.commit();
            
            const updatedRoomSnap = await getDoc(roomRef);
            const updatedRoomData = updatedRoomSnap.data();

            const settings = updatedRoomData.gameSettings;
            if (settings.mode === 'questions' && updatedRoomData.questionNumber >= settings.value) {
                await updateDoc(roomRef, { gameState: 'finished' });
            } else {
                setTimeout(() => {
                    if(updatedRoomData.players[userId]?.isHost) {
                       generateAndSetNewQuestion(updatedRoomData);
                    }
                }, 3000);
            }
        }
        
        // --- Single Player Logic ---

        function startSinglePlayerGame() {
            singlePlayerState = {
                score: 0,
                questionsAsked: 0,
                lives: gameSettings.mode === 'survival' ? 3 : Infinity
            };
            
            showScreen('game-screen');
            document.getElementById('player2-info').style.visibility = 'hidden';
            document.getElementById('player1-info').style.margin = '0 auto';
            document.getElementById('player1-name').textContent = `Mode: ${gameSettings.mode}`;
            
            getNextQuestion();
        }

        function getNextQuestion() {
            if (gameMode === 'single') {
                getNewSinglePlayerQuestion();
            }
        }

        async function getNewSinglePlayerQuestion() {
            clearTimers();
            loaderGame.classList.remove('hidden');
            gameContent.style.display = 'none';
            feedbackMessage.textContent = '';
            nextQuestionBtn.classList.add('hidden');
            answerInput.value = '';
            answerInput.disabled = false;
            submitAnswerBtn.disabled = false;

            updateSinglePlayerUI();

            const prompt = `Generate a single, challenging trivia question about general knowledge. Return ONLY a valid JSON object with "question" and "answer" keys.`;
            const responseText = await callGemini(prompt);
            
            loaderGame.classList.add('hidden');
            gameContent.style.display = 'block';

            if(responseText) {
                try {
                    const cleanedText = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                    const data = JSON.parse(cleanedText);
                    questionTextEl.textContent = data.question;
                    correctAnswer = data.answer;
                    startSinglePlayerTimer();
                } catch(e) {
                    questionTextEl.textContent = "Error loading question. Please try again.";
                    nextQuestionBtn.classList.remove('hidden');
                }
            }
        }
        
        function startSinglePlayerTimer() {
            let timeLeft = 10;
            timerEl.textContent = timeLeft;
            timerInterval = setInterval(() => {
                timeLeft--;
                timerEl.textContent = timeLeft;
                if (timeLeft <= 0) {
                    checkSinglePlayerAnswer(true); // Time's up
                }
            }, 1000);
        }

        function handleAnswerSubmission() {
            if (gameMode === 'single') {
                checkSinglePlayerAnswer(false);
            } else if (gameMode === 'friends' && currentRoomId) {
                const answerText = answerInput.value.trim();
                if (!answerText) return;
                
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const roomRef = doc(db, "artifacts", appId, "public/data/rooms", currentRoomId);
                updateDoc(roomRef, { [`answers.${userId}`]: answerText });
                answerInput.disabled = true;
                submitAnswerBtn.disabled = true;
            }
        }

        function checkSinglePlayerAnswer(isTimeUp) {
            clearTimers();
            const userAnswer = answerInput.value.trim().toLowerCase();
            const isCorrect = !isTimeUp && userAnswer === correctAnswer.toLowerCase().trim();
            
            answerInput.disabled = true;
            submitAnswerBtn.disabled = true;
            singlePlayerState.questionsAsked++;

            if (isCorrect) {
                singlePlayerState.score += 10;
                feedbackMessage.textContent = "Correct! 🎉";
                feedbackMessage.className = 'text-center text-2xl font-bold mt-6 text-green-400';
            } else if (isTimeUp) {
                singlePlayerState.lives--;
                feedbackMessage.textContent = `Time's up! The answer was: ${correctAnswer}`;
                feedbackMessage.className = 'text-center text-2xl font-bold mt-6 text-red-400';
            } else {
                singlePlayerState.lives--;
                feedbackMessage.textContent = `Incorrect. The answer was: ${correctAnswer}`;
                feedbackMessage.className = 'text-center text-2xl font-bold mt-6 text-red-400';
            }
            
            updateSinglePlayerUI();

            questionTimeout = setTimeout(() => {
                if (gameSettings.mode === 'survival' && singlePlayerState.lives <= 0) {
                    endSinglePlayerGame("You ran out of lives!");
                } else if (gameSettings.mode === 'questions' && singlePlayerState.questionsAsked >= gameSettings.value) {
                    endSinglePlayerGame("You completed all questions!");
                } else {
                    nextQuestionBtn.classList.remove('hidden');
                }
            }, 2000);
        }

        function updateSinglePlayerUI() {
             let scoreText = `Score: ${singlePlayerState.score}`;
             if(gameSettings.mode === 'survival') {
                 scoreText += ` | Lives: ${singlePlayerState.lives > 0 ? '❤️'.repeat(singlePlayerState.lives) : '💀'}`;
             } else if (gameSettings.mode === 'questions') {
                 scoreText += ` | Q: ${singlePlayerState.questionsAsked + 1} / ${gameSettings.value}`;
             }
             document.getElementById('player1-score').textContent = scoreText;
        }

        function endSinglePlayerGame(message) {
            clearTimers();
            document.getElementById('game-over-message').textContent = message;
            const finalScoresEl = document.getElementById('final-scores');
            finalScoresEl.innerHTML = `<p>Your Final Score: ${singlePlayerState.score}</p>`;
            showScreen('game-over-screen');
        }

        // --- General Game Flow ---

        function showGameOver(roomData) {
            clearTimers();
            if(roomUnsubscribe) roomUnsubscribe();
            
            const finalScoresEl = document.getElementById('final-scores');
            finalScoresEl.innerHTML = '';
            const players = Object.values(roomData.players).sort((a,b) => b.score - a.score);
            const winner = players[0];
            const isTie = players.length > 1 && players[0].score === players[1].score;
            
            const title = document.getElementById('game-over-message');
            title.textContent = isTie ? "It's a tie!" : `${winner.name} wins!`;

            players.forEach(p => {
                const scoreLine = document.createElement('div');
                scoreLine.textContent = `${p.name}: ${p.score} points`;
                finalScoresEl.appendChild(scoreLine);
            });

            showScreen('game-over-screen');
        }
        
        function clearTimers() {
            clearInterval(timerInterval);
            clearTimeout(questionTimeout);
            timerInterval = null;
            questionTimeout = null;
        }

        async function resetToHome() {
            clearTimers();
            if (roomUnsubscribe) {
                roomUnsubscribe();
                roomUnsubscribe = null;
            }
            if(currentRoomId) {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const roomRef = doc(db, "artifacts", appId, "public/data/rooms", currentRoomId);
                const roomSnap = await getDoc(roomRef);
                if(roomSnap.exists()) {
                    const isHost = roomSnap.data().players[userId]?.isHost;
                    if(isHost) {
                       await deleteDoc(roomRef);
                    }
                }
            }
            currentRoomId = null;
            gameMode = null;
            gameSettings = { mode: null, value: null };
            singlePlayerState = {};
            timerEl.textContent = '10';
            showScreen('home-screen');
        }

        // --- Initial Load ---
        async function startApp() {
            const success = await initializeFirebase();
            if (success) {
                setupListeners();
                showScreen('home-screen');
            }
        }

        const checkInterval = setInterval(() => {
            // Wait for the platform to inject the config and token
            if (typeof __firebase_config !== 'undefined' && typeof __initial_auth_token !== 'undefined') {
                clearInterval(checkInterval);
                startApp();
            }
        }, 100); // Check every 100ms

        window.addEventListener('beforeunload', (event) => {
            if (currentRoomId) {
                resetToHome(); 
            }
        });

    </script>
</body>
</html>
